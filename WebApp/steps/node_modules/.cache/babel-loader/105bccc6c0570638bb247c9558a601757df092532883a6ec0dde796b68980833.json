{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/User/Desktop/\\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/davidson/project/DavidsonProject/WebApp/steps/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"C:/Users/User/Desktop/\\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/davidson/project/DavidsonProject/WebApp/steps/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/User/Desktop/\\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/davidson/project/DavidsonProject/WebApp/steps/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/User/Desktop/\\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/davidson/project/DavidsonProject/WebApp/steps/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @typedef {Object} UserConfig\n * @property {string | HTMLElement} [target='.bentogrid'] - The target element to apply the grid to.\n * @property {number} [minCellWidth=100] - The minimum width of each cell in the grid.\n * @property {number} [columns=undefined] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [cellGap=0] - The space between each cell in the grid.\n * @property {number} [aspectRatio=1/1] - The aspect ratio of each cell in the grid.\n * @property {Object.<number, Breakpoint>} [breakpoints] - Breakpoints to set responsive grid behavior. minWidth looks at breakpointReference.\n * @property {string} [breakpointReference='target'] - Select if the breakpoints should reference to the target's or the window's width.\n * @property {boolean} [balanceFillers=false] - Whether to balance the position of the fillers. If set, they change their position with other elements.\n */\n/**\n * @typedef {Object} Breakpoint\n * @property {number} [minCellWidth] - The minimum width of each cell in the grid.\n * @property {number} [cellGap] - The space between each cell in the grid.\n * @property {number} [columns] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [aspectRatio] - The aspect ratio of each cell in the grid.\n */\nvar BentoGrid = /*#__PURE__*/function () {\n  /**\n   * Create a new BentoGrid instance.\n   * @param {UserConfig} userConfig - User configuration for the grid.\n   */\n  function BentoGrid(userConfig) {\n    _classCallCheck(this, BentoGrid);\n    this.config = _objectSpread(_objectSpread({}, {\n      target: '.bentogrid',\n      minCellWidth: 100,\n      cellGap: 0,\n      aspectRatio: 1 / 1,\n      breakpoints: [],\n      balanceFillers: false,\n      breakpointReference: 'target'\n    }), userConfig);\n    // Check if config.target is a string or an HTMLElement\n    this.gridContainer = typeof this.config.target === \"string\" ? document.querySelector(this.config.target) : this.config.target;\n    this.gridItems = undefined;\n    this.fillers = undefined;\n    this.setElements();\n    this.prevTotalColumns = null;\n    this.prevColumnCount = null;\n    this.hideOriginalFillers();\n    this.setupGrid();\n    this.updateGrid();\n    this.handleResponsiveBehavior();\n  }\n  _createClass(BentoGrid, [{\n    key: \"setElements\",\n    value: function setElements() {\n      // Grid items with the 'data-bento' attribute\n      this.gridItems = Array.from(this.gridContainer.querySelectorAll(\":scope > *\")).filter(function (item) {\n        return item.hasAttribute(\"data-bento\");\n      })\n      // items that are visible\n      .filter(function (item) {\n        return item.offsetParent !== null;\n      });\n\n      // Fillers that do not have the 'data-bento' attribute and are not set by the script\n      this.fillers = Array.from(this.gridContainer.querySelectorAll(\":scope > *\")).filter(function (item) {\n        return !item.hasAttribute(\"data-bento\");\n      }).filter(function (filler) {\n        return !filler.style.gridColumn;\n      });\n    }\n  }, {\n    key: \"getBreakpoint\",\n    value: function getBreakpoint() {\n      var width = this.config.breakpointReference === \"target\" ? this.gridContainer.clientWidth : window.innerWidth;\n      var activeBreakpoint = _objectSpread({}, this.config);\n      var cleanupBreakpoint = function cleanupBreakpoint(breakpoint) {\n        if (breakpoint.columns) {\n          delete activeBreakpoint.minCellWidth;\n        } else if (breakpoint.minCellWidth) {\n          delete activeBreakpoint.columns;\n        }\n      };\n      cleanupBreakpoint(activeBreakpoint);\n      var breakpointKeys = Object.keys(this.config.breakpoints).map(Number).sort(function (a, b) {\n        return a - b;\n      });\n      var _iterator = _createForOfIteratorHelper(breakpointKeys),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var breakpointKey = _step.value;\n          if (width >= breakpointKey) {\n            activeBreakpoint = _objectSpread(_objectSpread({}, activeBreakpoint), this.config.breakpoints[breakpointKey]);\n            cleanupBreakpoint(this.config.breakpoints[breakpointKey]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return activeBreakpoint;\n    }\n  }, {\n    key: \"setupGrid\",\n    value: function setupGrid() {\n      var breakpoint = this.getBreakpoint();\n\n      // Calculate the total number of columns\n      var totalColumns = breakpoint.columns || Math.floor((this.gridContainer.clientWidth + breakpoint.cellGap) / (breakpoint.minCellWidth + breakpoint.cellGap));\n\n      // Configure the grid container styles\n      this.gridContainer.style.display = \"grid\";\n      this.gridContainer.style.gridTemplateColumns = \"repeat(\".concat(totalColumns, \", minmax(\").concat(breakpoint.minCellWidth, \"px, 1fr))\");\n      this.gridContainer.style.gridGap = \"\".concat(breakpoint.cellGap, \"px\");\n\n      // Calculate the cell width based on the container width, total columns and cell gap\n      var containerWidth = this.gridContainer.clientWidth;\n      var cellWidth = (containerWidth - (totalColumns - 1) * breakpoint.cellGap) / totalColumns;\n\n      // Calculate the row height based on the aspect ratio and cell width\n      var rowHeight = cellWidth / breakpoint.aspectRatio;\n\n      // Set the row height as a CSS variable to read it later in the updateGrid method\n      this.gridContainer.style.setProperty(\"--bento-row-height\", \"\".concat(rowHeight, \"px\"));\n      return totalColumns;\n    }\n  }, {\n    key: \"hideOriginalFillers\",\n    value: function hideOriginalFillers() {\n      this.fillers.forEach(function (filler) {\n        filler.style.display = \"none\";\n      });\n    }\n  }, {\n    key: \"removeClonedFillers\",\n    value: function removeClonedFillers() {\n      // Fillers that are visible\n      Array.from(this.gridContainer.querySelectorAll(\":scope > *\")).filter(function (item) {\n        return !item.hasAttribute(\"data-bento\");\n      }).filter(function (filler) {\n        return !!filler.style.gridColumn;\n      }).forEach(function (filler) {\n        filler.remove();\n      });\n    }\n  }, {\n    key: \"updateGrid\",\n    value: function updateGrid() {\n      var _this = this;\n      var totalColumns = this.setupGrid();\n      if (this.prevTotalColumns !== totalColumns) {\n        this.removeClonedFillers();\n      }\n      var gridMatrix = [];\n      var maxRow = 0;\n\n      // Initialize the grid matrix\n      for (var i = 0; i < totalColumns; i++) {\n        gridMatrix[i] = [];\n      }\n      function getNextAvailablePosition(gridColumnSpan, gridRowSpan) {\n        var foundPosition = false;\n        var column = 0;\n        var row = 0;\n        while (!foundPosition) {\n          if (isPositionAvailable(column, row, gridColumnSpan, gridRowSpan)) {\n            foundPosition = true;\n          } else {\n            column++;\n            if (column + gridColumnSpan > totalColumns) {\n              column = 0;\n              row++;\n            }\n          }\n        }\n        return {\n          column: column,\n          row: row\n        };\n      }\n      function isPositionAvailable(column, row, gridColumnSpan, gridRowSpan) {\n        for (var c = column; c < column + gridColumnSpan; c++) {\n          for (var r = row; r < row + gridRowSpan; r++) {\n            if (gridMatrix[c] && gridMatrix[c][r]) {\n              return false;\n            }\n          }\n        }\n        return true;\n      }\n      function occupyPosition(column, row, gridColumnSpan, gridRowSpan) {\n        for (var c = column; c < column + gridColumnSpan; c++) {\n          for (var r = row; r < row + gridRowSpan; r++) {\n            if (!gridMatrix[c]) {\n              gridMatrix[c] = [];\n            }\n            gridMatrix[c][r] = true;\n          }\n        }\n      }\n      this.gridItems.forEach(function (item) {\n        var bento = item.getAttribute(\"data-bento\").split(\"x\");\n        var gridColumnSpan = parseInt(bento[0]);\n        var gridRowSpan = parseInt(bento[1]);\n        var position = getNextAvailablePosition(gridColumnSpan, gridRowSpan);\n        item.style.gridColumn = \"\".concat(position.column + 1, \" / span \").concat(gridColumnSpan);\n        item.style.gridRow = \"\".concat(position.row + 1, \" / span \").concat(gridRowSpan);\n        occupyPosition(position.column, position.row, gridColumnSpan, gridRowSpan);\n\n        // Update maxRow\n        maxRow = Math.max(maxRow, position.row + gridRowSpan);\n      });\n      this.gridContainer.style.gridTemplateRows = \"repeat(\".concat(maxRow, \", minmax(var(--bento-row-height), 1fr))\");\n\n      // Find the maximum row\n      this.gridItems.forEach(function (item) {\n        var gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n        var gridRowSpan = parseInt(item.style.gridRow.split(\" / \")[1].split(\" \")[1]);\n        maxRow = Math.max(maxRow, gridRowStart + gridRowSpan - 1);\n      });\n      var addFillers = function addFillers() {\n        var fillerIndex = 0;\n        var lastFillerPositions = [];\n        var _loop = function _loop(row) {\n          var _loop2 = function _loop2(column) {\n            if (!gridMatrix[column][row]) {\n              var gridColumnSpan = 1;\n              var gridRowSpan = 1;\n\n              // Find the maximum gridColumnSpan\n              while (column + gridColumnSpan < totalColumns && !gridMatrix[column + gridColumnSpan][row]) {\n                gridColumnSpan++;\n              }\n\n              // Find the maximum gridRowSpan\n              for (var r = row + 1; r < maxRow; r++) {\n                var rowSpanValid = true;\n                for (var c = column; c < column + gridColumnSpan; c++) {\n                  if (gridMatrix[c][r]) {\n                    rowSpanValid = false;\n                    break;\n                  }\n                }\n                if (!rowSpanValid) {\n                  break;\n                }\n                gridRowSpan++;\n              }\n              var filler;\n              if (_this.fillers.length > 0) {\n                // Clone the filler\n                filler = _this.fillers[fillerIndex].cloneNode(true);\n                // Update the filler index for the next iteration\n                fillerIndex = (fillerIndex + 1) % _this.fillers.length;\n                filler.style.display = \"block\";\n              } else {\n                // Create a new div if no fillers are available\n                filler = document.createElement(\"div\");\n              }\n              filler.classList.add(\"bento-filler\");\n              filler.style.gridColumn = \"\".concat(column + 1, \" / span \").concat(gridColumnSpan);\n              filler.style.gridRow = \"\".concat(row + 1, \" / span \").concat(gridRowSpan);\n              var swapPerformed = false;\n\n              // Swap the filler element with an existing element of the same size, if available\n              if (_this.config.balanceFillers) {\n                var availableSwaps = Array.from(_this.gridItems).filter(function (item) {\n                  return !item.hasAttribute(\"data-bento-no-swap\");\n                }).filter(function (item) {\n                  var gridColumnStart = parseInt(item.style.gridColumn.split(\" / \")[0]);\n                  var gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n                  var gridColumnEnd = parseInt(item.style.gridColumn.split(\" / \")[1].split(\" \")[1]);\n                  var gridRowEnd = parseInt(item.style.gridRow.split(\" / \")[1].split(\" \")[1]);\n                  return gridColumnEnd === gridColumnSpan && gridRowEnd === gridRowSpan && (gridColumnStart !== column + 1 || gridRowStart !== row + 1);\n                });\n                if (availableSwaps.length > 0) {\n                  var getNextPositionDistance = function getNextPositionDistance(current, next) {\n                    return Math.abs(current.column - next.column) + Math.abs(current.row - next.row);\n                  };\n                  var getAverageSwapsDistance = function getAverageSwapsDistance(swaps, newSwap) {\n                    if (swaps.length === 0) return 0;\n                    var totalDistance = swaps.reduce(function (sum, swap) {\n                      return sum + getNextPositionDistance(swap, newSwap);\n                    }, 0);\n                    return totalDistance / swaps.length;\n                  };\n                  var bestSwap = availableSwaps.reduce(function (best, current) {\n                    var currentAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                      column: parseInt(current.style.gridColumn.split(\" / \")[0]) - 1,\n                      row: parseInt(current.style.gridRow.split(\" / \")[0]) - 1\n                    });\n                    var bestAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                      column: parseInt(best.style.gridColumn.split(\" / \")[0]) - 1,\n                      row: parseInt(best.style.gridRow.split(\" / \")[0]) - 1\n                    });\n                    return currentAvgDistance > bestAvgDistance ? current : best;\n                  }, availableSwaps[0]);\n                  var originalGridColumn = bestSwap.style.gridColumn;\n                  var originalGridRow = bestSwap.style.gridRow;\n                  bestSwap.style.gridColumn = filler.style.gridColumn;\n                  bestSwap.style.gridRow = filler.style.gridRow;\n                  filler.style.gridColumn = originalGridColumn;\n                  filler.style.gridRow = originalGridRow;\n                  lastFillerPositions.push({\n                    column: parseInt(filler.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(filler.style.gridRow.split(\" / \")[0]) - 1\n                  });\n                  swapPerformed = true;\n                }\n              }\n\n              // Update gridMatrix\n              occupyPosition(column, row, gridColumnSpan, gridRowSpan);\n              _this.gridContainer.appendChild(filler);\n            }\n          };\n          for (var column = 0; column < totalColumns; column++) {\n            _loop2(column);\n          }\n        };\n        for (var row = 0; row < maxRow; row++) {\n          _loop(row);\n        }\n      };\n      addFillers();\n      this.prevTotalColumns = totalColumns;\n      this.emitCalculationDoneEvent();\n    }\n  }, {\n    key: \"handleResponsiveBehavior\",\n    value: function handleResponsiveBehavior() {\n      var _this2 = this;\n      var onResize = function onResize() {\n        clearTimeout(_this2.resizeObserver._timeoutId);\n        _this2.resizeObserver._timeoutId = setTimeout(function () {\n          var currentColumnCount = _this2.setupGrid();\n          if (currentColumnCount !== _this2.prevColumnCount) {\n            _this2.updateGrid();\n          }\n          _this2.prevColumnCount = currentColumnCount;\n        }, 10);\n      };\n      if (this.config.breakpointReference === 'window') {\n        this.resizeObserver = {\n          observe: function observe() {\n            window.addEventListener('resize', onResize);\n          },\n          unobserve: function unobserve() {\n            window.removeEventListener('resize', onResize);\n          }\n        };\n      } else {\n        this.resizeObserver = new ResizeObserver(onResize);\n      }\n      this.resizeObserver.observe(this.gridContainer);\n    }\n\n    /**\n     * Recalculate the grid layout.\n     * Useful for cases when elements are added, removed, or visibility changes.\n     */\n  }, {\n    key: \"recalculate\",\n    value: function recalculate() {\n      this.setElements();\n      this.updateGrid();\n    }\n\n    /**\n     * Emits a \"calculationDone\" event when the grid calculation is completed.\n     * @method\n     * @emits {CustomEvent} calculationDone - The event object contains a \"detail\" property with the gridContainer as a property.\n     */\n  }, {\n    key: \"emitCalculationDoneEvent\",\n    value: function emitCalculationDoneEvent() {\n      var calculationDoneEvent = new CustomEvent(\"calculationDone\", {\n        detail: {\n          gridContainer: this.gridContainer\n        }\n      });\n      this.gridContainer.dispatchEvent(calculationDoneEvent);\n    }\n  }]);\n  return BentoGrid;\n}();\nexport default BentoGrid;","map":{"version":3,"names":["BentoGrid","userConfig","_classCallCheck","config","_objectSpread","target","minCellWidth","cellGap","aspectRatio","breakpoints","balanceFillers","breakpointReference","gridContainer","document","querySelector","gridItems","undefined","fillers","setElements","prevTotalColumns","prevColumnCount","hideOriginalFillers","setupGrid","updateGrid","handleResponsiveBehavior","_createClass","key","value","Array","from","querySelectorAll","filter","item","hasAttribute","offsetParent","filler","style","gridColumn","getBreakpoint","width","clientWidth","window","innerWidth","activeBreakpoint","cleanupBreakpoint","breakpoint","columns","breakpointKeys","Object","keys","map","Number","sort","a","b","_iterator","_createForOfIteratorHelper","_step","s","n","done","breakpointKey","err","e","f","totalColumns","Math","floor","display","gridTemplateColumns","concat","gridGap","containerWidth","cellWidth","rowHeight","setProperty","forEach","removeClonedFillers","remove","_this","gridMatrix","maxRow","i","getNextAvailablePosition","gridColumnSpan","gridRowSpan","foundPosition","column","row","isPositionAvailable","c","r","occupyPosition","bento","getAttribute","split","parseInt","position","gridRow","max","gridTemplateRows","gridRowStart","addFillers","fillerIndex","lastFillerPositions","_loop","_loop2","rowSpanValid","length","cloneNode","createElement","classList","add","swapPerformed","availableSwaps","gridColumnStart","gridColumnEnd","gridRowEnd","getNextPositionDistance","current","next","abs","getAverageSwapsDistance","swaps","newSwap","totalDistance","reduce","sum","swap","bestSwap","best","currentAvgDistance","bestAvgDistance","originalGridColumn","originalGridRow","push","appendChild","emitCalculationDoneEvent","_this2","onResize","clearTimeout","resizeObserver","_timeoutId","setTimeout","currentColumnCount","observe","addEventListener","unobserve","removeEventListener","ResizeObserver","recalculate","calculationDoneEvent","CustomEvent","detail","dispatchEvent"],"sources":["C:/Users/User/Desktop/תכנות/davidson/project/DavidsonProject/WebApp/steps/node_modules/@bentogrid/core/BentoGrid.js"],"sourcesContent":["/**\n * @typedef {Object} UserConfig\n * @property {string | HTMLElement} [target='.bentogrid'] - The target element to apply the grid to.\n * @property {number} [minCellWidth=100] - The minimum width of each cell in the grid.\n * @property {number} [columns=undefined] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [cellGap=0] - The space between each cell in the grid.\n * @property {number} [aspectRatio=1/1] - The aspect ratio of each cell in the grid.\n * @property {Object.<number, Breakpoint>} [breakpoints] - Breakpoints to set responsive grid behavior. minWidth looks at breakpointReference.\n * @property {string} [breakpointReference='target'] - Select if the breakpoints should reference to the target's or the window's width.\n * @property {boolean} [balanceFillers=false] - Whether to balance the position of the fillers. If set, they change their position with other elements.\n */\n\n/**\n * @typedef {Object} Breakpoint\n * @property {number} [minCellWidth] - The minimum width of each cell in the grid.\n * @property {number} [cellGap] - The space between each cell in the grid.\n * @property {number} [columns] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [aspectRatio] - The aspect ratio of each cell in the grid.\n */\n\nclass BentoGrid {\n  /**\n   * Create a new BentoGrid instance.\n   * @param {UserConfig} userConfig - User configuration for the grid.\n   */\n  constructor(userConfig) {\n    this.config = {\n      ...{\n        target: '.bentogrid',\n        minCellWidth: 100,\n        cellGap: 0,\n        aspectRatio: 1 / 1,\n        breakpoints: [],\n        balanceFillers: false,\n        breakpointReference: 'target',\n      },\n      ...userConfig,\n    };\n    // Check if config.target is a string or an HTMLElement\n    this.gridContainer =\n      typeof this.config.target === \"string\"\n        ? document.querySelector(this.config.target)\n        : this.config.target;\n\n    this.gridItems = undefined;\n    this.fillers = undefined;\n    this.setElements();\n\n    this.prevTotalColumns = null;\n    this.prevColumnCount = null;\n\n    this.hideOriginalFillers();\n    this.setupGrid();\n    this.updateGrid();\n\n    this.handleResponsiveBehavior();\n  }\n\n  setElements() {\n    // Grid items with the 'data-bento' attribute\n    this.gridItems = Array\n      .from(this.gridContainer.querySelectorAll(\":scope > *\"))\n      .filter(item => item.hasAttribute(\"data-bento\"))\n      // items that are visible\n      .filter(item => item.offsetParent !== null);\n\n    // Fillers that do not have the 'data-bento' attribute and are not set by the script\n    this.fillers = Array\n      .from(this.gridContainer.querySelectorAll(\":scope > *\"))\n      .filter((item) => !item.hasAttribute(\"data-bento\"))\n      .filter(filler => !filler.style.gridColumn);\n  }\n\n  getBreakpoint() {\n    const width = this.config.breakpointReference === \"target\"\n      ? this.gridContainer.clientWidth\n      : window.innerWidth;\n\n    let activeBreakpoint = { ...this.config };\n\n    const cleanupBreakpoint = (breakpoint) => {\n      if (breakpoint.columns) {\n        delete activeBreakpoint.minCellWidth;\n      } else if (breakpoint.minCellWidth) {\n        delete activeBreakpoint.columns;\n      }\n    }\n\n    cleanupBreakpoint(activeBreakpoint)\n\n    const breakpointKeys = Object.keys(this.config.breakpoints).map(Number).sort((a, b) => a - b);\n\n    for (const breakpointKey of breakpointKeys) {\n      if (width >= breakpointKey) {\n        activeBreakpoint = { ...activeBreakpoint, ...this.config.breakpoints[breakpointKey] };\n        cleanupBreakpoint(this.config.breakpoints[breakpointKey])\n      }\n    }\n\n    return activeBreakpoint;\n  }\n\n  setupGrid() {\n    const breakpoint = this.getBreakpoint();\n\n    // Calculate the total number of columns\n    const totalColumns = breakpoint.columns || Math.floor(\n      (this.gridContainer.clientWidth + breakpoint.cellGap) /\n      (breakpoint.minCellWidth + breakpoint.cellGap)\n    );\n\n    // Configure the grid container styles\n    this.gridContainer.style.display = \"grid\";\n    this.gridContainer.style.gridTemplateColumns = `repeat(${totalColumns}, minmax(${breakpoint.minCellWidth}px, 1fr))`;\n    this.gridContainer.style.gridGap = `${breakpoint.cellGap}px`;\n\n    // Calculate the cell width based on the container width, total columns and cell gap\n    const containerWidth = this.gridContainer.clientWidth;\n    const cellWidth = (containerWidth - (totalColumns - 1) * breakpoint.cellGap) / totalColumns;\n\n    // Calculate the row height based on the aspect ratio and cell width\n    const rowHeight = cellWidth / breakpoint.aspectRatio;\n\n    // Set the row height as a CSS variable to read it later in the updateGrid method\n    this.gridContainer.style.setProperty(\"--bento-row-height\", `${rowHeight}px`);\n\n    return totalColumns;\n  }\n\n  hideOriginalFillers() {\n    this.fillers.forEach((filler) => {\n      filler.style.display = \"none\";\n    });\n  }\n\n  removeClonedFillers() {\n    // Fillers that are visible\n    Array.from(\n      this.gridContainer.querySelectorAll(\":scope > *\")\n    ).filter((item) => !item.hasAttribute(\"data-bento\"))\n      .filter(filler => !!filler.style.gridColumn)\n      .forEach((filler) => {\n        filler.remove();\n      });\n  }\n\n  updateGrid() {\n    const totalColumns = this.setupGrid();\n\n    if (this.prevTotalColumns !== totalColumns) {\n      this.removeClonedFillers();\n    }\n\n    const gridMatrix = [];\n    let maxRow = 0;\n\n    // Initialize the grid matrix\n    for (let i = 0; i < totalColumns; i++) {\n      gridMatrix[i] = [];\n    }\n\n    function getNextAvailablePosition(gridColumnSpan, gridRowSpan) {\n      let foundPosition = false;\n      let column = 0;\n      let row = 0;\n\n      while (!foundPosition) {\n        if (isPositionAvailable(column, row, gridColumnSpan, gridRowSpan)) {\n          foundPosition = true;\n        } else {\n          column++;\n          if (column + gridColumnSpan > totalColumns) {\n            column = 0;\n            row++;\n          }\n        }\n      }\n\n      return { column, row };\n    }\n\n    function isPositionAvailable(column, row, gridColumnSpan, gridRowSpan) {\n      for (let c = column; c < column + gridColumnSpan; c++) {\n        for (let r = row; r < row + gridRowSpan; r++) {\n          if (gridMatrix[c] && gridMatrix[c][r]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    function occupyPosition(column, row, gridColumnSpan, gridRowSpan) {\n      for (let c = column; c < column + gridColumnSpan; c++) {\n        for (let r = row; r < row + gridRowSpan; r++) {\n          if (!gridMatrix[c]) {\n            gridMatrix[c] = [];\n          }\n          gridMatrix[c][r] = true;\n        }\n      }\n    }\n\n    this.gridItems.forEach((item) => {\n      const bento = item.getAttribute(\"data-bento\").split(\"x\");\n      const gridColumnSpan = parseInt(bento[0]);\n      const gridRowSpan = parseInt(bento[1]);\n\n      const position = getNextAvailablePosition(gridColumnSpan, gridRowSpan);\n      item.style.gridColumn = `${position.column + 1} / span ${gridColumnSpan}`;\n      item.style.gridRow = `${position.row + 1} / span ${gridRowSpan}`;\n\n      occupyPosition(\n        position.column,\n        position.row,\n        gridColumnSpan,\n        gridRowSpan\n      );\n\n      // Update maxRow\n      maxRow = Math.max(maxRow, position.row + gridRowSpan);\n    });\n\n    this.gridContainer.style.gridTemplateRows = `repeat(${maxRow}, minmax(var(--bento-row-height), 1fr))`;\n\n    // Find the maximum row\n    this.gridItems.forEach((item) => {\n      const gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n      const gridRowSpan = parseInt(\n        item.style.gridRow.split(\" / \")[1].split(\" \")[1]\n      );\n      maxRow = Math.max(maxRow, gridRowStart + gridRowSpan - 1);\n    });\n    const addFillers = () => {\n      let fillerIndex = 0;\n      let lastFillerPositions = [];\n\n      for (let row = 0; row < maxRow; row++) {\n        for (let column = 0; column < totalColumns; column++) {\n          if (!gridMatrix[column][row]) {\n            let gridColumnSpan = 1;\n            let gridRowSpan = 1;\n\n            // Find the maximum gridColumnSpan\n            while (\n              column + gridColumnSpan < totalColumns &&\n              !gridMatrix[column + gridColumnSpan][row]\n            ) {\n              gridColumnSpan++;\n            }\n\n            // Find the maximum gridRowSpan\n            for (let r = row + 1; r < maxRow; r++) {\n              let rowSpanValid = true;\n              for (let c = column; c < column + gridColumnSpan; c++) {\n                if (gridMatrix[c][r]) {\n                  rowSpanValid = false;\n                  break;\n                }\n              }\n              if (!rowSpanValid) {\n                break;\n              }\n              gridRowSpan++;\n            }\n\n            let filler;\n            if (this.fillers.length > 0) {\n              // Clone the filler\n              filler = this.fillers[fillerIndex].cloneNode(true);\n              // Update the filler index for the next iteration\n              fillerIndex = (fillerIndex + 1) % this.fillers.length;\n              filler.style.display = \"block\";\n            } else {\n              // Create a new div if no fillers are available\n              filler = document.createElement(\"div\");\n            }\n\n            filler.classList.add(\"bento-filler\");\n            filler.style.gridColumn = `${column + 1} / span ${gridColumnSpan}`;\n            filler.style.gridRow = `${row + 1} / span ${gridRowSpan}`;\n\n            let swapPerformed = false;\n\n            // Swap the filler element with an existing element of the same size, if available\n            if (this.config.balanceFillers) {\n              const availableSwaps = Array.from(this.gridItems)\n                .filter(item => !item.hasAttribute(\"data-bento-no-swap\"))\n                .filter((item) => {\n                  const gridColumnStart = parseInt(item.style.gridColumn.split(\" / \")[0]);\n                  const gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n                  const gridColumnEnd = parseInt(item.style.gridColumn.split(\" / \")[1].split(\" \")[1]);\n                  const gridRowEnd = parseInt(item.style.gridRow.split(\" / \")[1].split(\" \")[1]);\n\n                  return (\n                    gridColumnEnd === gridColumnSpan &&\n                    gridRowEnd === gridRowSpan &&\n                    (gridColumnStart !== column + 1 || gridRowStart !== row + 1)\n                  );\n                });\n\n              if (availableSwaps.length > 0) {\n                const getNextPositionDistance = (current, next) => {\n                  return Math.abs(current.column - next.column) + Math.abs(current.row - next.row);\n                };\n\n                const getAverageSwapsDistance = (swaps, newSwap) => {\n                  if (swaps.length === 0) return 0;\n                  const totalDistance = swaps.reduce((sum, swap) => {\n                    return sum + getNextPositionDistance(swap, newSwap);\n                  }, 0);\n                  return totalDistance / swaps.length;\n                };\n\n                const bestSwap = availableSwaps.reduce((best, current) => {\n                  const currentAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                    column: parseInt(current.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(current.style.gridRow.split(\" / \")[0]) - 1,\n                  });\n\n                  const bestAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                    column: parseInt(best.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(best.style.gridRow.split(\" / \")[0]) - 1,\n                  });\n\n                  return currentAvgDistance > bestAvgDistance ? current : best;\n                }, availableSwaps[0]);\n\n                const originalGridColumn = bestSwap.style.gridColumn;\n                const originalGridRow = bestSwap.style.gridRow;\n                bestSwap.style.gridColumn = filler.style.gridColumn;\n                bestSwap.style.gridRow = filler.style.gridRow;\n                filler.style.gridColumn = originalGridColumn;\n                filler.style.gridRow = originalGridRow;\n\n                lastFillerPositions.push({\n                  column: parseInt(filler.style.gridColumn.split(\" / \")[0]) - 1,\n                  row: parseInt(filler.style.gridRow.split(\" / \")[0]) - 1,\n                });\n                swapPerformed = true;\n              }\n\n            }\n\n            // Update gridMatrix\n            occupyPosition(column, row, gridColumnSpan, gridRowSpan);\n\n            this.gridContainer.appendChild(filler);\n          }\n        }\n      }\n    }\n\n    addFillers();\n\n    this.prevTotalColumns = totalColumns;\n\n    this.emitCalculationDoneEvent();\n  }\n\n  handleResponsiveBehavior() {\n    const onResize = () => {\n      clearTimeout(this.resizeObserver._timeoutId);\n      this.resizeObserver._timeoutId = setTimeout(() => {\n        const currentColumnCount = this.setupGrid();\n        if (currentColumnCount !== this.prevColumnCount) {\n          this.updateGrid();\n        }\n        this.prevColumnCount = currentColumnCount;\n      }, 10);\n    };\n\n    if (this.config.breakpointReference === 'window') {\n      this.resizeObserver = {\n        observe: () => {\n          window.addEventListener('resize', onResize);\n        },\n        unobserve: () => {\n          window.removeEventListener('resize', onResize);\n        },\n      };\n    } else {\n      this.resizeObserver = new ResizeObserver(onResize);\n    }\n\n    this.resizeObserver.observe(this.gridContainer);\n  }\n\n  /**\n   * Recalculate the grid layout.\n   * Useful for cases when elements are added, removed, or visibility changes.\n   */\n  recalculate() {\n    this.setElements();\n    this.updateGrid();\n  }\n\n  /**\n   * Emits a \"calculationDone\" event when the grid calculation is completed.\n   * @method\n   * @emits {CustomEvent} calculationDone - The event object contains a \"detail\" property with the gridContainer as a property.\n   */\n  emitCalculationDoneEvent() {\n    const calculationDoneEvent = new CustomEvent(\"calculationDone\", {\n      detail: {\n        gridContainer: this.gridContainer,\n      },\n    });\n    this.gridContainer.dispatchEvent(calculationDoneEvent);\n  }\n}\n\nexport default BentoGrid;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}