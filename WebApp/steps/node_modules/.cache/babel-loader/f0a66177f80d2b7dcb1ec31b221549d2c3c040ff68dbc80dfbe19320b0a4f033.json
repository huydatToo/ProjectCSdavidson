{"ast":null,"code":"/**\n * @typedef {Object} UserConfig\n * @property {string | HTMLElement} [target='.bentogrid'] - The target element to apply the grid to.\n * @property {number} [minCellWidth=100] - The minimum width of each cell in the grid.\n * @property {number} [columns=undefined] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [cellGap=0] - The space between each cell in the grid.\n * @property {number} [aspectRatio=1/1] - The aspect ratio of each cell in the grid.\n * @property {Object.<number, Breakpoint>} [breakpoints] - Breakpoints to set responsive grid behavior. minWidth looks at breakpointReference.\n * @property {string} [breakpointReference='target'] - Select if the breakpoints should reference to the target's or the window's width.\n * @property {boolean} [balanceFillers=false] - Whether to balance the position of the fillers. If set, they change their position with other elements.\n */\n\n/**\n * @typedef {Object} Breakpoint\n * @property {number} [minCellWidth] - The minimum width of each cell in the grid.\n * @property {number} [cellGap] - The space between each cell in the grid.\n * @property {number} [columns] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [aspectRatio] - The aspect ratio of each cell in the grid.\n */\n\nclass BentoGrid {\n  /**\n   * Create a new BentoGrid instance.\n   * @param {UserConfig} userConfig - User configuration for the grid.\n   */\n  constructor(userConfig) {\n    this.config = {\n      ...{\n        target: '.bentogrid',\n        minCellWidth: 100,\n        cellGap: 0,\n        aspectRatio: 1 / 1,\n        breakpoints: [],\n        balanceFillers: false,\n        breakpointReference: 'target'\n      },\n      ...userConfig\n    };\n    // Check if config.target is a string or an HTMLElement\n    this.gridContainer = typeof this.config.target === \"string\" ? document.querySelector(this.config.target) : this.config.target;\n    this.gridItems = undefined;\n    this.fillers = undefined;\n    this.setElements();\n    this.prevTotalColumns = null;\n    this.prevColumnCount = null;\n    this.hideOriginalFillers();\n    this.setupGrid();\n    this.updateGrid();\n    this.handleResponsiveBehavior();\n  }\n  setElements() {\n    // Grid items with the 'data-bento' attribute\n    this.gridItems = Array.from(this.gridContainer.querySelectorAll(\":scope > *\")).filter(item => item.hasAttribute(\"data-bento\"))\n    // items that are visible\n    .filter(item => item.offsetParent !== null);\n\n    // Fillers that do not have the 'data-bento' attribute and are not set by the script\n    this.fillers = Array.from(this.gridContainer.querySelectorAll(\":scope > *\")).filter(item => !item.hasAttribute(\"data-bento\")).filter(filler => !filler.style.gridColumn);\n  }\n  getBreakpoint() {\n    const width = this.config.breakpointReference === \"target\" ? this.gridContainer.clientWidth : window.innerWidth;\n    let activeBreakpoint = {\n      ...this.config\n    };\n    const cleanupBreakpoint = breakpoint => {\n      if (breakpoint.columns) {\n        delete activeBreakpoint.minCellWidth;\n      } else if (breakpoint.minCellWidth) {\n        delete activeBreakpoint.columns;\n      }\n    };\n    cleanupBreakpoint(activeBreakpoint);\n    const breakpointKeys = Object.keys(this.config.breakpoints).map(Number).sort((a, b) => a - b);\n    for (const breakpointKey of breakpointKeys) {\n      if (width >= breakpointKey) {\n        activeBreakpoint = {\n          ...activeBreakpoint,\n          ...this.config.breakpoints[breakpointKey]\n        };\n        cleanupBreakpoint(this.config.breakpoints[breakpointKey]);\n      }\n    }\n    return activeBreakpoint;\n  }\n  setupGrid() {\n    const breakpoint = this.getBreakpoint();\n\n    // Calculate the total number of columns\n    const totalColumns = breakpoint.columns || Math.floor((this.gridContainer.clientWidth + breakpoint.cellGap) / (breakpoint.minCellWidth + breakpoint.cellGap));\n\n    // Configure the grid container styles\n    this.gridContainer.style.display = \"grid\";\n    this.gridContainer.style.gridTemplateColumns = `repeat(${totalColumns}, minmax(${breakpoint.minCellWidth}px, 1fr))`;\n    this.gridContainer.style.gridGap = `${breakpoint.cellGap}px`;\n\n    // Calculate the cell width based on the container width, total columns and cell gap\n    const containerWidth = this.gridContainer.clientWidth;\n    const cellWidth = (containerWidth - (totalColumns - 1) * breakpoint.cellGap) / totalColumns;\n\n    // Calculate the row height based on the aspect ratio and cell width\n    const rowHeight = cellWidth / breakpoint.aspectRatio;\n\n    // Set the row height as a CSS variable to read it later in the updateGrid method\n    this.gridContainer.style.setProperty(\"--bento-row-height\", `${rowHeight}px`);\n    return totalColumns;\n  }\n  hideOriginalFillers() {\n    this.fillers.forEach(filler => {\n      filler.style.display = \"none\";\n    });\n  }\n  removeClonedFillers() {\n    // Fillers that are visible\n    Array.from(this.gridContainer.querySelectorAll(\":scope > *\")).filter(item => !item.hasAttribute(\"data-bento\")).filter(filler => !!filler.style.gridColumn).forEach(filler => {\n      filler.remove();\n    });\n  }\n  updateGrid() {\n    const totalColumns = this.setupGrid();\n    if (this.prevTotalColumns !== totalColumns) {\n      this.removeClonedFillers();\n    }\n    const gridMatrix = [];\n    let maxRow = 0;\n\n    // Initialize the grid matrix\n    for (let i = 0; i < totalColumns; i++) {\n      gridMatrix[i] = [];\n    }\n    function getNextAvailablePosition(gridColumnSpan, gridRowSpan) {\n      let foundPosition = false;\n      let column = 0;\n      let row = 0;\n      while (!foundPosition) {\n        if (isPositionAvailable(column, row, gridColumnSpan, gridRowSpan)) {\n          foundPosition = true;\n        } else {\n          column++;\n          if (column + gridColumnSpan > totalColumns) {\n            column = 0;\n            row++;\n          }\n        }\n      }\n      return {\n        column,\n        row\n      };\n    }\n    function isPositionAvailable(column, row, gridColumnSpan, gridRowSpan) {\n      for (let c = column; c < column + gridColumnSpan; c++) {\n        for (let r = row; r < row + gridRowSpan; r++) {\n          if (gridMatrix[c] && gridMatrix[c][r]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    function occupyPosition(column, row, gridColumnSpan, gridRowSpan) {\n      for (let c = column; c < column + gridColumnSpan; c++) {\n        for (let r = row; r < row + gridRowSpan; r++) {\n          if (!gridMatrix[c]) {\n            gridMatrix[c] = [];\n          }\n          gridMatrix[c][r] = true;\n        }\n      }\n    }\n    this.gridItems.forEach(item => {\n      const bento = item.getAttribute(\"data-bento\").split(\"x\");\n      const gridColumnSpan = parseInt(bento[0]);\n      const gridRowSpan = parseInt(bento[1]);\n      const position = getNextAvailablePosition(gridColumnSpan, gridRowSpan);\n      item.style.gridColumn = `${position.column + 1} / span ${gridColumnSpan}`;\n      item.style.gridRow = `${position.row + 1} / span ${gridRowSpan}`;\n      occupyPosition(position.column, position.row, gridColumnSpan, gridRowSpan);\n\n      // Update maxRow\n      maxRow = Math.max(maxRow, position.row + gridRowSpan);\n    });\n    this.gridContainer.style.gridTemplateRows = `repeat(${maxRow}, minmax(var(--bento-row-height), 1fr))`;\n\n    // Find the maximum row\n    this.gridItems.forEach(item => {\n      const gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n      const gridRowSpan = parseInt(item.style.gridRow.split(\" / \")[1].split(\" \")[1]);\n      maxRow = Math.max(maxRow, gridRowStart + gridRowSpan - 1);\n    });\n    const addFillers = () => {\n      let fillerIndex = 0;\n      let lastFillerPositions = [];\n      for (let row = 0; row < maxRow; row++) {\n        for (let column = 0; column < totalColumns; column++) {\n          if (!gridMatrix[column][row]) {\n            let gridColumnSpan = 1;\n            let gridRowSpan = 1;\n\n            // Find the maximum gridColumnSpan\n            while (column + gridColumnSpan < totalColumns && !gridMatrix[column + gridColumnSpan][row]) {\n              gridColumnSpan++;\n            }\n\n            // Find the maximum gridRowSpan\n            for (let r = row + 1; r < maxRow; r++) {\n              let rowSpanValid = true;\n              for (let c = column; c < column + gridColumnSpan; c++) {\n                if (gridMatrix[c][r]) {\n                  rowSpanValid = false;\n                  break;\n                }\n              }\n              if (!rowSpanValid) {\n                break;\n              }\n              gridRowSpan++;\n            }\n            let filler;\n            if (this.fillers.length > 0) {\n              // Clone the filler\n              filler = this.fillers[fillerIndex].cloneNode(true);\n              // Update the filler index for the next iteration\n              fillerIndex = (fillerIndex + 1) % this.fillers.length;\n              filler.style.display = \"block\";\n            } else {\n              // Create a new div if no fillers are available\n              filler = document.createElement(\"div\");\n            }\n            filler.classList.add(\"bento-filler\");\n            filler.style.gridColumn = `${column + 1} / span ${gridColumnSpan}`;\n            filler.style.gridRow = `${row + 1} / span ${gridRowSpan}`;\n            let swapPerformed = false;\n\n            // Swap the filler element with an existing element of the same size, if available\n            if (this.config.balanceFillers) {\n              const availableSwaps = Array.from(this.gridItems).filter(item => !item.hasAttribute(\"data-bento-no-swap\")).filter(item => {\n                const gridColumnStart = parseInt(item.style.gridColumn.split(\" / \")[0]);\n                const gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n                const gridColumnEnd = parseInt(item.style.gridColumn.split(\" / \")[1].split(\" \")[1]);\n                const gridRowEnd = parseInt(item.style.gridRow.split(\" / \")[1].split(\" \")[1]);\n                return gridColumnEnd === gridColumnSpan && gridRowEnd === gridRowSpan && (gridColumnStart !== column + 1 || gridRowStart !== row + 1);\n              });\n              if (availableSwaps.length > 0) {\n                const getNextPositionDistance = (current, next) => {\n                  return Math.abs(current.column - next.column) + Math.abs(current.row - next.row);\n                };\n                const getAverageSwapsDistance = (swaps, newSwap) => {\n                  if (swaps.length === 0) return 0;\n                  const totalDistance = swaps.reduce((sum, swap) => {\n                    return sum + getNextPositionDistance(swap, newSwap);\n                  }, 0);\n                  return totalDistance / swaps.length;\n                };\n                const bestSwap = availableSwaps.reduce((best, current) => {\n                  const currentAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                    column: parseInt(current.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(current.style.gridRow.split(\" / \")[0]) - 1\n                  });\n                  const bestAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                    column: parseInt(best.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(best.style.gridRow.split(\" / \")[0]) - 1\n                  });\n                  return currentAvgDistance > bestAvgDistance ? current : best;\n                }, availableSwaps[0]);\n                const originalGridColumn = bestSwap.style.gridColumn;\n                const originalGridRow = bestSwap.style.gridRow;\n                bestSwap.style.gridColumn = filler.style.gridColumn;\n                bestSwap.style.gridRow = filler.style.gridRow;\n                filler.style.gridColumn = originalGridColumn;\n                filler.style.gridRow = originalGridRow;\n                lastFillerPositions.push({\n                  column: parseInt(filler.style.gridColumn.split(\" / \")[0]) - 1,\n                  row: parseInt(filler.style.gridRow.split(\" / \")[0]) - 1\n                });\n                swapPerformed = true;\n              }\n            }\n\n            // Update gridMatrix\n            occupyPosition(column, row, gridColumnSpan, gridRowSpan);\n            this.gridContainer.appendChild(filler);\n          }\n        }\n      }\n    };\n    addFillers();\n    this.prevTotalColumns = totalColumns;\n    this.emitCalculationDoneEvent();\n  }\n  handleResponsiveBehavior() {\n    const onResize = () => {\n      clearTimeout(this.resizeObserver._timeoutId);\n      this.resizeObserver._timeoutId = setTimeout(() => {\n        const currentColumnCount = this.setupGrid();\n        if (currentColumnCount !== this.prevColumnCount) {\n          this.updateGrid();\n        }\n        this.prevColumnCount = currentColumnCount;\n      }, 10);\n    };\n    if (this.config.breakpointReference === 'window') {\n      this.resizeObserver = {\n        observe: () => {\n          window.addEventListener('resize', onResize);\n        },\n        unobserve: () => {\n          window.removeEventListener('resize', onResize);\n        }\n      };\n    } else {\n      this.resizeObserver = new ResizeObserver(onResize);\n    }\n    this.resizeObserver.observe(this.gridContainer);\n  }\n\n  /**\n   * Recalculate the grid layout.\n   * Useful for cases when elements are added, removed, or visibility changes.\n   */\n  recalculate() {\n    this.setElements();\n    this.updateGrid();\n  }\n\n  /**\n   * Emits a \"calculationDone\" event when the grid calculation is completed.\n   * @method\n   * @emits {CustomEvent} calculationDone - The event object contains a \"detail\" property with the gridContainer as a property.\n   */\n  emitCalculationDoneEvent() {\n    const calculationDoneEvent = new CustomEvent(\"calculationDone\", {\n      detail: {\n        gridContainer: this.gridContainer\n      }\n    });\n    this.gridContainer.dispatchEvent(calculationDoneEvent);\n  }\n}\nexport default BentoGrid;","map":{"version":3,"names":["BentoGrid","constructor","userConfig","config","target","minCellWidth","cellGap","aspectRatio","breakpoints","balanceFillers","breakpointReference","gridContainer","document","querySelector","gridItems","undefined","fillers","setElements","prevTotalColumns","prevColumnCount","hideOriginalFillers","setupGrid","updateGrid","handleResponsiveBehavior","Array","from","querySelectorAll","filter","item","hasAttribute","offsetParent","filler","style","gridColumn","getBreakpoint","width","clientWidth","window","innerWidth","activeBreakpoint","cleanupBreakpoint","breakpoint","columns","breakpointKeys","Object","keys","map","Number","sort","a","b","breakpointKey","totalColumns","Math","floor","display","gridTemplateColumns","gridGap","containerWidth","cellWidth","rowHeight","setProperty","forEach","removeClonedFillers","remove","gridMatrix","maxRow","i","getNextAvailablePosition","gridColumnSpan","gridRowSpan","foundPosition","column","row","isPositionAvailable","c","r","occupyPosition","bento","getAttribute","split","parseInt","position","gridRow","max","gridTemplateRows","gridRowStart","addFillers","fillerIndex","lastFillerPositions","rowSpanValid","length","cloneNode","createElement","classList","add","swapPerformed","availableSwaps","gridColumnStart","gridColumnEnd","gridRowEnd","getNextPositionDistance","current","next","abs","getAverageSwapsDistance","swaps","newSwap","totalDistance","reduce","sum","swap","bestSwap","best","currentAvgDistance","bestAvgDistance","originalGridColumn","originalGridRow","push","appendChild","emitCalculationDoneEvent","onResize","clearTimeout","resizeObserver","_timeoutId","setTimeout","currentColumnCount","observe","addEventListener","unobserve","removeEventListener","ResizeObserver","recalculate","calculationDoneEvent","CustomEvent","detail","dispatchEvent"],"sources":["C:/Users/User/Desktop/תכנות/davidson/project/DavidsonProject/WebApp/steps/node_modules/@bentogrid/core/BentoGrid.js"],"sourcesContent":["/**\n * @typedef {Object} UserConfig\n * @property {string | HTMLElement} [target='.bentogrid'] - The target element to apply the grid to.\n * @property {number} [minCellWidth=100] - The minimum width of each cell in the grid.\n * @property {number} [columns=undefined] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [cellGap=0] - The space between each cell in the grid.\n * @property {number} [aspectRatio=1/1] - The aspect ratio of each cell in the grid.\n * @property {Object.<number, Breakpoint>} [breakpoints] - Breakpoints to set responsive grid behavior. minWidth looks at breakpointReference.\n * @property {string} [breakpointReference='target'] - Select if the breakpoints should reference to the target's or the window's width.\n * @property {boolean} [balanceFillers=false] - Whether to balance the position of the fillers. If set, they change their position with other elements.\n */\n\n/**\n * @typedef {Object} Breakpoint\n * @property {number} [minCellWidth] - The minimum width of each cell in the grid.\n * @property {number} [cellGap] - The space between each cell in the grid.\n * @property {number} [columns] - The number of columns to use for the grid. This overrides minCellWidth.\n * @property {number} [aspectRatio] - The aspect ratio of each cell in the grid.\n */\n\nclass BentoGrid {\n  /**\n   * Create a new BentoGrid instance.\n   * @param {UserConfig} userConfig - User configuration for the grid.\n   */\n  constructor(userConfig) {\n    this.config = {\n      ...{\n        target: '.bentogrid',\n        minCellWidth: 100,\n        cellGap: 0,\n        aspectRatio: 1 / 1,\n        breakpoints: [],\n        balanceFillers: false,\n        breakpointReference: 'target',\n      },\n      ...userConfig,\n    };\n    // Check if config.target is a string or an HTMLElement\n    this.gridContainer =\n      typeof this.config.target === \"string\"\n        ? document.querySelector(this.config.target)\n        : this.config.target;\n\n    this.gridItems = undefined;\n    this.fillers = undefined;\n    this.setElements();\n\n    this.prevTotalColumns = null;\n    this.prevColumnCount = null;\n\n    this.hideOriginalFillers();\n    this.setupGrid();\n    this.updateGrid();\n\n    this.handleResponsiveBehavior();\n  }\n\n  setElements() {\n    // Grid items with the 'data-bento' attribute\n    this.gridItems = Array\n      .from(this.gridContainer.querySelectorAll(\":scope > *\"))\n      .filter(item => item.hasAttribute(\"data-bento\"))\n      // items that are visible\n      .filter(item => item.offsetParent !== null);\n\n    // Fillers that do not have the 'data-bento' attribute and are not set by the script\n    this.fillers = Array\n      .from(this.gridContainer.querySelectorAll(\":scope > *\"))\n      .filter((item) => !item.hasAttribute(\"data-bento\"))\n      .filter(filler => !filler.style.gridColumn);\n  }\n\n  getBreakpoint() {\n    const width = this.config.breakpointReference === \"target\"\n      ? this.gridContainer.clientWidth\n      : window.innerWidth;\n\n    let activeBreakpoint = { ...this.config };\n\n    const cleanupBreakpoint = (breakpoint) => {\n      if (breakpoint.columns) {\n        delete activeBreakpoint.minCellWidth;\n      } else if (breakpoint.minCellWidth) {\n        delete activeBreakpoint.columns;\n      }\n    }\n\n    cleanupBreakpoint(activeBreakpoint)\n\n    const breakpointKeys = Object.keys(this.config.breakpoints).map(Number).sort((a, b) => a - b);\n\n    for (const breakpointKey of breakpointKeys) {\n      if (width >= breakpointKey) {\n        activeBreakpoint = { ...activeBreakpoint, ...this.config.breakpoints[breakpointKey] };\n        cleanupBreakpoint(this.config.breakpoints[breakpointKey])\n      }\n    }\n\n    return activeBreakpoint;\n  }\n\n  setupGrid() {\n    const breakpoint = this.getBreakpoint();\n\n    // Calculate the total number of columns\n    const totalColumns = breakpoint.columns || Math.floor(\n      (this.gridContainer.clientWidth + breakpoint.cellGap) /\n      (breakpoint.minCellWidth + breakpoint.cellGap)\n    );\n\n    // Configure the grid container styles\n    this.gridContainer.style.display = \"grid\";\n    this.gridContainer.style.gridTemplateColumns = `repeat(${totalColumns}, minmax(${breakpoint.minCellWidth}px, 1fr))`;\n    this.gridContainer.style.gridGap = `${breakpoint.cellGap}px`;\n\n    // Calculate the cell width based on the container width, total columns and cell gap\n    const containerWidth = this.gridContainer.clientWidth;\n    const cellWidth = (containerWidth - (totalColumns - 1) * breakpoint.cellGap) / totalColumns;\n\n    // Calculate the row height based on the aspect ratio and cell width\n    const rowHeight = cellWidth / breakpoint.aspectRatio;\n\n    // Set the row height as a CSS variable to read it later in the updateGrid method\n    this.gridContainer.style.setProperty(\"--bento-row-height\", `${rowHeight}px`);\n\n    return totalColumns;\n  }\n\n  hideOriginalFillers() {\n    this.fillers.forEach((filler) => {\n      filler.style.display = \"none\";\n    });\n  }\n\n  removeClonedFillers() {\n    // Fillers that are visible\n    Array.from(\n      this.gridContainer.querySelectorAll(\":scope > *\")\n    ).filter((item) => !item.hasAttribute(\"data-bento\"))\n      .filter(filler => !!filler.style.gridColumn)\n      .forEach((filler) => {\n        filler.remove();\n      });\n  }\n\n  updateGrid() {\n    const totalColumns = this.setupGrid();\n\n    if (this.prevTotalColumns !== totalColumns) {\n      this.removeClonedFillers();\n    }\n\n    const gridMatrix = [];\n    let maxRow = 0;\n\n    // Initialize the grid matrix\n    for (let i = 0; i < totalColumns; i++) {\n      gridMatrix[i] = [];\n    }\n\n    function getNextAvailablePosition(gridColumnSpan, gridRowSpan) {\n      let foundPosition = false;\n      let column = 0;\n      let row = 0;\n\n      while (!foundPosition) {\n        if (isPositionAvailable(column, row, gridColumnSpan, gridRowSpan)) {\n          foundPosition = true;\n        } else {\n          column++;\n          if (column + gridColumnSpan > totalColumns) {\n            column = 0;\n            row++;\n          }\n        }\n      }\n\n      return { column, row };\n    }\n\n    function isPositionAvailable(column, row, gridColumnSpan, gridRowSpan) {\n      for (let c = column; c < column + gridColumnSpan; c++) {\n        for (let r = row; r < row + gridRowSpan; r++) {\n          if (gridMatrix[c] && gridMatrix[c][r]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    function occupyPosition(column, row, gridColumnSpan, gridRowSpan) {\n      for (let c = column; c < column + gridColumnSpan; c++) {\n        for (let r = row; r < row + gridRowSpan; r++) {\n          if (!gridMatrix[c]) {\n            gridMatrix[c] = [];\n          }\n          gridMatrix[c][r] = true;\n        }\n      }\n    }\n\n    this.gridItems.forEach((item) => {\n      const bento = item.getAttribute(\"data-bento\").split(\"x\");\n      const gridColumnSpan = parseInt(bento[0]);\n      const gridRowSpan = parseInt(bento[1]);\n\n      const position = getNextAvailablePosition(gridColumnSpan, gridRowSpan);\n      item.style.gridColumn = `${position.column + 1} / span ${gridColumnSpan}`;\n      item.style.gridRow = `${position.row + 1} / span ${gridRowSpan}`;\n\n      occupyPosition(\n        position.column,\n        position.row,\n        gridColumnSpan,\n        gridRowSpan\n      );\n\n      // Update maxRow\n      maxRow = Math.max(maxRow, position.row + gridRowSpan);\n    });\n\n    this.gridContainer.style.gridTemplateRows = `repeat(${maxRow}, minmax(var(--bento-row-height), 1fr))`;\n\n    // Find the maximum row\n    this.gridItems.forEach((item) => {\n      const gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n      const gridRowSpan = parseInt(\n        item.style.gridRow.split(\" / \")[1].split(\" \")[1]\n      );\n      maxRow = Math.max(maxRow, gridRowStart + gridRowSpan - 1);\n    });\n    const addFillers = () => {\n      let fillerIndex = 0;\n      let lastFillerPositions = [];\n\n      for (let row = 0; row < maxRow; row++) {\n        for (let column = 0; column < totalColumns; column++) {\n          if (!gridMatrix[column][row]) {\n            let gridColumnSpan = 1;\n            let gridRowSpan = 1;\n\n            // Find the maximum gridColumnSpan\n            while (\n              column + gridColumnSpan < totalColumns &&\n              !gridMatrix[column + gridColumnSpan][row]\n            ) {\n              gridColumnSpan++;\n            }\n\n            // Find the maximum gridRowSpan\n            for (let r = row + 1; r < maxRow; r++) {\n              let rowSpanValid = true;\n              for (let c = column; c < column + gridColumnSpan; c++) {\n                if (gridMatrix[c][r]) {\n                  rowSpanValid = false;\n                  break;\n                }\n              }\n              if (!rowSpanValid) {\n                break;\n              }\n              gridRowSpan++;\n            }\n\n            let filler;\n            if (this.fillers.length > 0) {\n              // Clone the filler\n              filler = this.fillers[fillerIndex].cloneNode(true);\n              // Update the filler index for the next iteration\n              fillerIndex = (fillerIndex + 1) % this.fillers.length;\n              filler.style.display = \"block\";\n            } else {\n              // Create a new div if no fillers are available\n              filler = document.createElement(\"div\");\n            }\n\n            filler.classList.add(\"bento-filler\");\n            filler.style.gridColumn = `${column + 1} / span ${gridColumnSpan}`;\n            filler.style.gridRow = `${row + 1} / span ${gridRowSpan}`;\n\n            let swapPerformed = false;\n\n            // Swap the filler element with an existing element of the same size, if available\n            if (this.config.balanceFillers) {\n              const availableSwaps = Array.from(this.gridItems)\n                .filter(item => !item.hasAttribute(\"data-bento-no-swap\"))\n                .filter((item) => {\n                  const gridColumnStart = parseInt(item.style.gridColumn.split(\" / \")[0]);\n                  const gridRowStart = parseInt(item.style.gridRow.split(\" / \")[0]);\n                  const gridColumnEnd = parseInt(item.style.gridColumn.split(\" / \")[1].split(\" \")[1]);\n                  const gridRowEnd = parseInt(item.style.gridRow.split(\" / \")[1].split(\" \")[1]);\n\n                  return (\n                    gridColumnEnd === gridColumnSpan &&\n                    gridRowEnd === gridRowSpan &&\n                    (gridColumnStart !== column + 1 || gridRowStart !== row + 1)\n                  );\n                });\n\n              if (availableSwaps.length > 0) {\n                const getNextPositionDistance = (current, next) => {\n                  return Math.abs(current.column - next.column) + Math.abs(current.row - next.row);\n                };\n\n                const getAverageSwapsDistance = (swaps, newSwap) => {\n                  if (swaps.length === 0) return 0;\n                  const totalDistance = swaps.reduce((sum, swap) => {\n                    return sum + getNextPositionDistance(swap, newSwap);\n                  }, 0);\n                  return totalDistance / swaps.length;\n                };\n\n                const bestSwap = availableSwaps.reduce((best, current) => {\n                  const currentAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                    column: parseInt(current.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(current.style.gridRow.split(\" / \")[0]) - 1,\n                  });\n\n                  const bestAvgDistance = getAverageSwapsDistance(lastFillerPositions, {\n                    column: parseInt(best.style.gridColumn.split(\" / \")[0]) - 1,\n                    row: parseInt(best.style.gridRow.split(\" / \")[0]) - 1,\n                  });\n\n                  return currentAvgDistance > bestAvgDistance ? current : best;\n                }, availableSwaps[0]);\n\n                const originalGridColumn = bestSwap.style.gridColumn;\n                const originalGridRow = bestSwap.style.gridRow;\n                bestSwap.style.gridColumn = filler.style.gridColumn;\n                bestSwap.style.gridRow = filler.style.gridRow;\n                filler.style.gridColumn = originalGridColumn;\n                filler.style.gridRow = originalGridRow;\n\n                lastFillerPositions.push({\n                  column: parseInt(filler.style.gridColumn.split(\" / \")[0]) - 1,\n                  row: parseInt(filler.style.gridRow.split(\" / \")[0]) - 1,\n                });\n                swapPerformed = true;\n              }\n\n            }\n\n            // Update gridMatrix\n            occupyPosition(column, row, gridColumnSpan, gridRowSpan);\n\n            this.gridContainer.appendChild(filler);\n          }\n        }\n      }\n    }\n\n    addFillers();\n\n    this.prevTotalColumns = totalColumns;\n\n    this.emitCalculationDoneEvent();\n  }\n\n  handleResponsiveBehavior() {\n    const onResize = () => {\n      clearTimeout(this.resizeObserver._timeoutId);\n      this.resizeObserver._timeoutId = setTimeout(() => {\n        const currentColumnCount = this.setupGrid();\n        if (currentColumnCount !== this.prevColumnCount) {\n          this.updateGrid();\n        }\n        this.prevColumnCount = currentColumnCount;\n      }, 10);\n    };\n\n    if (this.config.breakpointReference === 'window') {\n      this.resizeObserver = {\n        observe: () => {\n          window.addEventListener('resize', onResize);\n        },\n        unobserve: () => {\n          window.removeEventListener('resize', onResize);\n        },\n      };\n    } else {\n      this.resizeObserver = new ResizeObserver(onResize);\n    }\n\n    this.resizeObserver.observe(this.gridContainer);\n  }\n\n  /**\n   * Recalculate the grid layout.\n   * Useful for cases when elements are added, removed, or visibility changes.\n   */\n  recalculate() {\n    this.setElements();\n    this.updateGrid();\n  }\n\n  /**\n   * Emits a \"calculationDone\" event when the grid calculation is completed.\n   * @method\n   * @emits {CustomEvent} calculationDone - The event object contains a \"detail\" property with the gridContainer as a property.\n   */\n  emitCalculationDoneEvent() {\n    const calculationDoneEvent = new CustomEvent(\"calculationDone\", {\n      detail: {\n        gridContainer: this.gridContainer,\n      },\n    });\n    this.gridContainer.dispatchEvent(calculationDoneEvent);\n  }\n}\n\nexport default BentoGrid;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,SAAS,CAAC;EACd;AACF;AACA;AACA;EACEC,WAAWA,CAACC,UAAU,EAAE;IACtB,IAAI,CAACC,MAAM,GAAG;MACZ,GAAG;QACDC,MAAM,EAAE,YAAY;QACpBC,YAAY,EAAE,GAAG;QACjBC,OAAO,EAAE,CAAC;QACVC,WAAW,EAAE,CAAC,GAAG,CAAC;QAClBC,WAAW,EAAE,EAAE;QACfC,cAAc,EAAE,KAAK;QACrBC,mBAAmB,EAAE;MACvB,CAAC;MACD,GAAGR;IACL,CAAC;IACD;IACA,IAAI,CAACS,aAAa,GAChB,OAAO,IAAI,CAACR,MAAM,CAACC,MAAM,KAAK,QAAQ,GAClCQ,QAAQ,CAACC,aAAa,CAAC,IAAI,CAACV,MAAM,CAACC,MAAM,CAAC,GAC1C,IAAI,CAACD,MAAM,CAACC,MAAM;IAExB,IAAI,CAACU,SAAS,GAAGC,SAAS;IAC1B,IAAI,CAACC,OAAO,GAAGD,SAAS;IACxB,IAAI,CAACE,WAAW,CAAC,CAAC;IAElB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,eAAe,GAAG,IAAI;IAE3B,IAAI,CAACC,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAACC,SAAS,CAAC,CAAC;IAChB,IAAI,CAACC,UAAU,CAAC,CAAC;IAEjB,IAAI,CAACC,wBAAwB,CAAC,CAAC;EACjC;EAEAN,WAAWA,CAAA,EAAG;IACZ;IACA,IAAI,CAACH,SAAS,GAAGU,KAAK,CACnBC,IAAI,CAAC,IAAI,CAACd,aAAa,CAACe,gBAAgB,CAAC,YAAY,CAAC,CAAC,CACvDC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,YAAY,CAAC,YAAY,CAAC;IAC/C;IAAA,CACCF,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACE,YAAY,KAAK,IAAI,CAAC;;IAE7C;IACA,IAAI,CAACd,OAAO,GAAGQ,KAAK,CACjBC,IAAI,CAAC,IAAI,CAACd,aAAa,CAACe,gBAAgB,CAAC,YAAY,CAAC,CAAC,CACvDC,MAAM,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACC,YAAY,CAAC,YAAY,CAAC,CAAC,CAClDF,MAAM,CAACI,MAAM,IAAI,CAACA,MAAM,CAACC,KAAK,CAACC,UAAU,CAAC;EAC/C;EAEAC,aAAaA,CAAA,EAAG;IACd,MAAMC,KAAK,GAAG,IAAI,CAAChC,MAAM,CAACO,mBAAmB,KAAK,QAAQ,GACtD,IAAI,CAACC,aAAa,CAACyB,WAAW,GAC9BC,MAAM,CAACC,UAAU;IAErB,IAAIC,gBAAgB,GAAG;MAAE,GAAG,IAAI,CAACpC;IAAO,CAAC;IAEzC,MAAMqC,iBAAiB,GAAIC,UAAU,IAAK;MACxC,IAAIA,UAAU,CAACC,OAAO,EAAE;QACtB,OAAOH,gBAAgB,CAAClC,YAAY;MACtC,CAAC,MAAM,IAAIoC,UAAU,CAACpC,YAAY,EAAE;QAClC,OAAOkC,gBAAgB,CAACG,OAAO;MACjC;IACF,CAAC;IAEDF,iBAAiB,CAACD,gBAAgB,CAAC;IAEnC,MAAMI,cAAc,GAAGC,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC1C,MAAM,CAACK,WAAW,CAAC,CAACsC,GAAG,CAACC,MAAM,CAAC,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;IAE7F,KAAK,MAAMC,aAAa,IAAIR,cAAc,EAAE;MAC1C,IAAIR,KAAK,IAAIgB,aAAa,EAAE;QAC1BZ,gBAAgB,GAAG;UAAE,GAAGA,gBAAgB;UAAE,GAAG,IAAI,CAACpC,MAAM,CAACK,WAAW,CAAC2C,aAAa;QAAE,CAAC;QACrFX,iBAAiB,CAAC,IAAI,CAACrC,MAAM,CAACK,WAAW,CAAC2C,aAAa,CAAC,CAAC;MAC3D;IACF;IAEA,OAAOZ,gBAAgB;EACzB;EAEAlB,SAASA,CAAA,EAAG;IACV,MAAMoB,UAAU,GAAG,IAAI,CAACP,aAAa,CAAC,CAAC;;IAEvC;IACA,MAAMkB,YAAY,GAAGX,UAAU,CAACC,OAAO,IAAIW,IAAI,CAACC,KAAK,CACnD,CAAC,IAAI,CAAC3C,aAAa,CAACyB,WAAW,GAAGK,UAAU,CAACnC,OAAO,KACnDmC,UAAU,CAACpC,YAAY,GAAGoC,UAAU,CAACnC,OAAO,CAC/C,CAAC;;IAED;IACA,IAAI,CAACK,aAAa,CAACqB,KAAK,CAACuB,OAAO,GAAG,MAAM;IACzC,IAAI,CAAC5C,aAAa,CAACqB,KAAK,CAACwB,mBAAmB,GAAI,UAASJ,YAAa,YAAWX,UAAU,CAACpC,YAAa,WAAU;IACnH,IAAI,CAACM,aAAa,CAACqB,KAAK,CAACyB,OAAO,GAAI,GAAEhB,UAAU,CAACnC,OAAQ,IAAG;;IAE5D;IACA,MAAMoD,cAAc,GAAG,IAAI,CAAC/C,aAAa,CAACyB,WAAW;IACrD,MAAMuB,SAAS,GAAG,CAACD,cAAc,GAAG,CAACN,YAAY,GAAG,CAAC,IAAIX,UAAU,CAACnC,OAAO,IAAI8C,YAAY;;IAE3F;IACA,MAAMQ,SAAS,GAAGD,SAAS,GAAGlB,UAAU,CAAClC,WAAW;;IAEpD;IACA,IAAI,CAACI,aAAa,CAACqB,KAAK,CAAC6B,WAAW,CAAC,oBAAoB,EAAG,GAAED,SAAU,IAAG,CAAC;IAE5E,OAAOR,YAAY;EACrB;EAEAhC,mBAAmBA,CAAA,EAAG;IACpB,IAAI,CAACJ,OAAO,CAAC8C,OAAO,CAAE/B,MAAM,IAAK;MAC/BA,MAAM,CAACC,KAAK,CAACuB,OAAO,GAAG,MAAM;IAC/B,CAAC,CAAC;EACJ;EAEAQ,mBAAmBA,CAAA,EAAG;IACpB;IACAvC,KAAK,CAACC,IAAI,CACR,IAAI,CAACd,aAAa,CAACe,gBAAgB,CAAC,YAAY,CAClD,CAAC,CAACC,MAAM,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACC,YAAY,CAAC,YAAY,CAAC,CAAC,CACjDF,MAAM,CAACI,MAAM,IAAI,CAAC,CAACA,MAAM,CAACC,KAAK,CAACC,UAAU,CAAC,CAC3C6B,OAAO,CAAE/B,MAAM,IAAK;MACnBA,MAAM,CAACiC,MAAM,CAAC,CAAC;IACjB,CAAC,CAAC;EACN;EAEA1C,UAAUA,CAAA,EAAG;IACX,MAAM8B,YAAY,GAAG,IAAI,CAAC/B,SAAS,CAAC,CAAC;IAErC,IAAI,IAAI,CAACH,gBAAgB,KAAKkC,YAAY,EAAE;MAC1C,IAAI,CAACW,mBAAmB,CAAC,CAAC;IAC5B;IAEA,MAAME,UAAU,GAAG,EAAE;IACrB,IAAIC,MAAM,GAAG,CAAC;;IAEd;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,YAAY,EAAEe,CAAC,EAAE,EAAE;MACrCF,UAAU,CAACE,CAAC,CAAC,GAAG,EAAE;IACpB;IAEA,SAASC,wBAAwBA,CAACC,cAAc,EAAEC,WAAW,EAAE;MAC7D,IAAIC,aAAa,GAAG,KAAK;MACzB,IAAIC,MAAM,GAAG,CAAC;MACd,IAAIC,GAAG,GAAG,CAAC;MAEX,OAAO,CAACF,aAAa,EAAE;QACrB,IAAIG,mBAAmB,CAACF,MAAM,EAAEC,GAAG,EAAEJ,cAAc,EAAEC,WAAW,CAAC,EAAE;UACjEC,aAAa,GAAG,IAAI;QACtB,CAAC,MAAM;UACLC,MAAM,EAAE;UACR,IAAIA,MAAM,GAAGH,cAAc,GAAGjB,YAAY,EAAE;YAC1CoB,MAAM,GAAG,CAAC;YACVC,GAAG,EAAE;UACP;QACF;MACF;MAEA,OAAO;QAAED,MAAM;QAAEC;MAAI,CAAC;IACxB;IAEA,SAASC,mBAAmBA,CAACF,MAAM,EAAEC,GAAG,EAAEJ,cAAc,EAAEC,WAAW,EAAE;MACrE,KAAK,IAAIK,CAAC,GAAGH,MAAM,EAAEG,CAAC,GAAGH,MAAM,GAAGH,cAAc,EAAEM,CAAC,EAAE,EAAE;QACrD,KAAK,IAAIC,CAAC,GAAGH,GAAG,EAAEG,CAAC,GAAGH,GAAG,GAAGH,WAAW,EAAEM,CAAC,EAAE,EAAE;UAC5C,IAAIX,UAAU,CAACU,CAAC,CAAC,IAAIV,UAAU,CAACU,CAAC,CAAC,CAACC,CAAC,CAAC,EAAE;YACrC,OAAO,KAAK;UACd;QACF;MACF;MACA,OAAO,IAAI;IACb;IAEA,SAASC,cAAcA,CAACL,MAAM,EAAEC,GAAG,EAAEJ,cAAc,EAAEC,WAAW,EAAE;MAChE,KAAK,IAAIK,CAAC,GAAGH,MAAM,EAAEG,CAAC,GAAGH,MAAM,GAAGH,cAAc,EAAEM,CAAC,EAAE,EAAE;QACrD,KAAK,IAAIC,CAAC,GAAGH,GAAG,EAAEG,CAAC,GAAGH,GAAG,GAAGH,WAAW,EAAEM,CAAC,EAAE,EAAE;UAC5C,IAAI,CAACX,UAAU,CAACU,CAAC,CAAC,EAAE;YAClBV,UAAU,CAACU,CAAC,CAAC,GAAG,EAAE;UACpB;UACAV,UAAU,CAACU,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,IAAI;QACzB;MACF;IACF;IAEA,IAAI,CAAC9D,SAAS,CAACgD,OAAO,CAAElC,IAAI,IAAK;MAC/B,MAAMkD,KAAK,GAAGlD,IAAI,CAACmD,YAAY,CAAC,YAAY,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC;MACxD,MAAMX,cAAc,GAAGY,QAAQ,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC;MACzC,MAAMR,WAAW,GAAGW,QAAQ,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC;MAEtC,MAAMI,QAAQ,GAAGd,wBAAwB,CAACC,cAAc,EAAEC,WAAW,CAAC;MACtE1C,IAAI,CAACI,KAAK,CAACC,UAAU,GAAI,GAAEiD,QAAQ,CAACV,MAAM,GAAG,CAAE,WAAUH,cAAe,EAAC;MACzEzC,IAAI,CAACI,KAAK,CAACmD,OAAO,GAAI,GAAED,QAAQ,CAACT,GAAG,GAAG,CAAE,WAAUH,WAAY,EAAC;MAEhEO,cAAc,CACZK,QAAQ,CAACV,MAAM,EACfU,QAAQ,CAACT,GAAG,EACZJ,cAAc,EACdC,WACF,CAAC;;MAED;MACAJ,MAAM,GAAGb,IAAI,CAAC+B,GAAG,CAAClB,MAAM,EAAEgB,QAAQ,CAACT,GAAG,GAAGH,WAAW,CAAC;IACvD,CAAC,CAAC;IAEF,IAAI,CAAC3D,aAAa,CAACqB,KAAK,CAACqD,gBAAgB,GAAI,UAASnB,MAAO,yCAAwC;;IAErG;IACA,IAAI,CAACpD,SAAS,CAACgD,OAAO,CAAElC,IAAI,IAAK;MAC/B,MAAM0D,YAAY,GAAGL,QAAQ,CAACrD,IAAI,CAACI,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACjE,MAAMV,WAAW,GAAGW,QAAQ,CAC1BrD,IAAI,CAACI,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CACjD,CAAC;MACDd,MAAM,GAAGb,IAAI,CAAC+B,GAAG,CAAClB,MAAM,EAAEoB,YAAY,GAAGhB,WAAW,GAAG,CAAC,CAAC;IAC3D,CAAC,CAAC;IACF,MAAMiB,UAAU,GAAGA,CAAA,KAAM;MACvB,IAAIC,WAAW,GAAG,CAAC;MACnB,IAAIC,mBAAmB,GAAG,EAAE;MAE5B,KAAK,IAAIhB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGP,MAAM,EAAEO,GAAG,EAAE,EAAE;QACrC,KAAK,IAAID,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGpB,YAAY,EAAEoB,MAAM,EAAE,EAAE;UACpD,IAAI,CAACP,UAAU,CAACO,MAAM,CAAC,CAACC,GAAG,CAAC,EAAE;YAC5B,IAAIJ,cAAc,GAAG,CAAC;YACtB,IAAIC,WAAW,GAAG,CAAC;;YAEnB;YACA,OACEE,MAAM,GAAGH,cAAc,GAAGjB,YAAY,IACtC,CAACa,UAAU,CAACO,MAAM,GAAGH,cAAc,CAAC,CAACI,GAAG,CAAC,EACzC;cACAJ,cAAc,EAAE;YAClB;;YAEA;YACA,KAAK,IAAIO,CAAC,GAAGH,GAAG,GAAG,CAAC,EAAEG,CAAC,GAAGV,MAAM,EAAEU,CAAC,EAAE,EAAE;cACrC,IAAIc,YAAY,GAAG,IAAI;cACvB,KAAK,IAAIf,CAAC,GAAGH,MAAM,EAAEG,CAAC,GAAGH,MAAM,GAAGH,cAAc,EAAEM,CAAC,EAAE,EAAE;gBACrD,IAAIV,UAAU,CAACU,CAAC,CAAC,CAACC,CAAC,CAAC,EAAE;kBACpBc,YAAY,GAAG,KAAK;kBACpB;gBACF;cACF;cACA,IAAI,CAACA,YAAY,EAAE;gBACjB;cACF;cACApB,WAAW,EAAE;YACf;YAEA,IAAIvC,MAAM;YACV,IAAI,IAAI,CAACf,OAAO,CAAC2E,MAAM,GAAG,CAAC,EAAE;cAC3B;cACA5D,MAAM,GAAG,IAAI,CAACf,OAAO,CAACwE,WAAW,CAAC,CAACI,SAAS,CAAC,IAAI,CAAC;cAClD;cACAJ,WAAW,GAAG,CAACA,WAAW,GAAG,CAAC,IAAI,IAAI,CAACxE,OAAO,CAAC2E,MAAM;cACrD5D,MAAM,CAACC,KAAK,CAACuB,OAAO,GAAG,OAAO;YAChC,CAAC,MAAM;cACL;cACAxB,MAAM,GAAGnB,QAAQ,CAACiF,aAAa,CAAC,KAAK,CAAC;YACxC;YAEA9D,MAAM,CAAC+D,SAAS,CAACC,GAAG,CAAC,cAAc,CAAC;YACpChE,MAAM,CAACC,KAAK,CAACC,UAAU,GAAI,GAAEuC,MAAM,GAAG,CAAE,WAAUH,cAAe,EAAC;YAClEtC,MAAM,CAACC,KAAK,CAACmD,OAAO,GAAI,GAAEV,GAAG,GAAG,CAAE,WAAUH,WAAY,EAAC;YAEzD,IAAI0B,aAAa,GAAG,KAAK;;YAEzB;YACA,IAAI,IAAI,CAAC7F,MAAM,CAACM,cAAc,EAAE;cAC9B,MAAMwF,cAAc,GAAGzE,KAAK,CAACC,IAAI,CAAC,IAAI,CAACX,SAAS,CAAC,CAC9Ca,MAAM,CAACC,IAAI,IAAI,CAACA,IAAI,CAACC,YAAY,CAAC,oBAAoB,CAAC,CAAC,CACxDF,MAAM,CAAEC,IAAI,IAAK;gBAChB,MAAMsE,eAAe,GAAGjB,QAAQ,CAACrD,IAAI,CAACI,KAAK,CAACC,UAAU,CAAC+C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvE,MAAMM,YAAY,GAAGL,QAAQ,CAACrD,IAAI,CAACI,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACjE,MAAMmB,aAAa,GAAGlB,QAAQ,CAACrD,IAAI,CAACI,KAAK,CAACC,UAAU,CAAC+C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnF,MAAMoB,UAAU,GAAGnB,QAAQ,CAACrD,IAAI,CAACI,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAE7E,OACEmB,aAAa,KAAK9B,cAAc,IAChC+B,UAAU,KAAK9B,WAAW,KACzB4B,eAAe,KAAK1B,MAAM,GAAG,CAAC,IAAIc,YAAY,KAAKb,GAAG,GAAG,CAAC,CAAC;cAEhE,CAAC,CAAC;cAEJ,IAAIwB,cAAc,CAACN,MAAM,GAAG,CAAC,EAAE;gBAC7B,MAAMU,uBAAuB,GAAGA,CAACC,OAAO,EAAEC,IAAI,KAAK;kBACjD,OAAOlD,IAAI,CAACmD,GAAG,CAACF,OAAO,CAAC9B,MAAM,GAAG+B,IAAI,CAAC/B,MAAM,CAAC,GAAGnB,IAAI,CAACmD,GAAG,CAACF,OAAO,CAAC7B,GAAG,GAAG8B,IAAI,CAAC9B,GAAG,CAAC;gBAClF,CAAC;gBAED,MAAMgC,uBAAuB,GAAGA,CAACC,KAAK,EAAEC,OAAO,KAAK;kBAClD,IAAID,KAAK,CAACf,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;kBAChC,MAAMiB,aAAa,GAAGF,KAAK,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;oBAChD,OAAOD,GAAG,GAAGT,uBAAuB,CAACU,IAAI,EAAEJ,OAAO,CAAC;kBACrD,CAAC,EAAE,CAAC,CAAC;kBACL,OAAOC,aAAa,GAAGF,KAAK,CAACf,MAAM;gBACrC,CAAC;gBAED,MAAMqB,QAAQ,GAAGf,cAAc,CAACY,MAAM,CAAC,CAACI,IAAI,EAAEX,OAAO,KAAK;kBACxD,MAAMY,kBAAkB,GAAGT,uBAAuB,CAAChB,mBAAmB,EAAE;oBACtEjB,MAAM,EAAES,QAAQ,CAACqB,OAAO,CAACtE,KAAK,CAACC,UAAU,CAAC+C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;oBAC9DP,GAAG,EAAEQ,QAAQ,CAACqB,OAAO,CAACtE,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;kBACzD,CAAC,CAAC;kBAEF,MAAMmC,eAAe,GAAGV,uBAAuB,CAAChB,mBAAmB,EAAE;oBACnEjB,MAAM,EAAES,QAAQ,CAACgC,IAAI,CAACjF,KAAK,CAACC,UAAU,CAAC+C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;oBAC3DP,GAAG,EAAEQ,QAAQ,CAACgC,IAAI,CAACjF,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;kBACtD,CAAC,CAAC;kBAEF,OAAOkC,kBAAkB,GAAGC,eAAe,GAAGb,OAAO,GAAGW,IAAI;gBAC9D,CAAC,EAAEhB,cAAc,CAAC,CAAC,CAAC,CAAC;gBAErB,MAAMmB,kBAAkB,GAAGJ,QAAQ,CAAChF,KAAK,CAACC,UAAU;gBACpD,MAAMoF,eAAe,GAAGL,QAAQ,CAAChF,KAAK,CAACmD,OAAO;gBAC9C6B,QAAQ,CAAChF,KAAK,CAACC,UAAU,GAAGF,MAAM,CAACC,KAAK,CAACC,UAAU;gBACnD+E,QAAQ,CAAChF,KAAK,CAACmD,OAAO,GAAGpD,MAAM,CAACC,KAAK,CAACmD,OAAO;gBAC7CpD,MAAM,CAACC,KAAK,CAACC,UAAU,GAAGmF,kBAAkB;gBAC5CrF,MAAM,CAACC,KAAK,CAACmD,OAAO,GAAGkC,eAAe;gBAEtC5B,mBAAmB,CAAC6B,IAAI,CAAC;kBACvB9C,MAAM,EAAES,QAAQ,CAAClD,MAAM,CAACC,KAAK,CAACC,UAAU,CAAC+C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;kBAC7DP,GAAG,EAAEQ,QAAQ,CAAClD,MAAM,CAACC,KAAK,CAACmD,OAAO,CAACH,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;gBACxD,CAAC,CAAC;gBACFgB,aAAa,GAAG,IAAI;cACtB;YAEF;;YAEA;YACAnB,cAAc,CAACL,MAAM,EAAEC,GAAG,EAAEJ,cAAc,EAAEC,WAAW,CAAC;YAExD,IAAI,CAAC3D,aAAa,CAAC4G,WAAW,CAACxF,MAAM,CAAC;UACxC;QACF;MACF;IACF,CAAC;IAEDwD,UAAU,CAAC,CAAC;IAEZ,IAAI,CAACrE,gBAAgB,GAAGkC,YAAY;IAEpC,IAAI,CAACoE,wBAAwB,CAAC,CAAC;EACjC;EAEAjG,wBAAwBA,CAAA,EAAG;IACzB,MAAMkG,QAAQ,GAAGA,CAAA,KAAM;MACrBC,YAAY,CAAC,IAAI,CAACC,cAAc,CAACC,UAAU,CAAC;MAC5C,IAAI,CAACD,cAAc,CAACC,UAAU,GAAGC,UAAU,CAAC,MAAM;QAChD,MAAMC,kBAAkB,GAAG,IAAI,CAACzG,SAAS,CAAC,CAAC;QAC3C,IAAIyG,kBAAkB,KAAK,IAAI,CAAC3G,eAAe,EAAE;UAC/C,IAAI,CAACG,UAAU,CAAC,CAAC;QACnB;QACA,IAAI,CAACH,eAAe,GAAG2G,kBAAkB;MAC3C,CAAC,EAAE,EAAE,CAAC;IACR,CAAC;IAED,IAAI,IAAI,CAAC3H,MAAM,CAACO,mBAAmB,KAAK,QAAQ,EAAE;MAChD,IAAI,CAACiH,cAAc,GAAG;QACpBI,OAAO,EAAEA,CAAA,KAAM;UACb1F,MAAM,CAAC2F,gBAAgB,CAAC,QAAQ,EAAEP,QAAQ,CAAC;QAC7C,CAAC;QACDQ,SAAS,EAAEA,CAAA,KAAM;UACf5F,MAAM,CAAC6F,mBAAmB,CAAC,QAAQ,EAAET,QAAQ,CAAC;QAChD;MACF,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACE,cAAc,GAAG,IAAIQ,cAAc,CAACV,QAAQ,CAAC;IACpD;IAEA,IAAI,CAACE,cAAc,CAACI,OAAO,CAAC,IAAI,CAACpH,aAAa,CAAC;EACjD;;EAEA;AACF;AACA;AACA;EACEyH,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACnH,WAAW,CAAC,CAAC;IAClB,IAAI,CAACK,UAAU,CAAC,CAAC;EACnB;;EAEA;AACF;AACA;AACA;AACA;EACEkG,wBAAwBA,CAAA,EAAG;IACzB,MAAMa,oBAAoB,GAAG,IAAIC,WAAW,CAAC,iBAAiB,EAAE;MAC9DC,MAAM,EAAE;QACN5H,aAAa,EAAE,IAAI,CAACA;MACtB;IACF,CAAC,CAAC;IACF,IAAI,CAACA,aAAa,CAAC6H,aAAa,CAACH,oBAAoB,CAAC;EACxD;AACF;AAEA,eAAerI,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}